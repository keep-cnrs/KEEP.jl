using LinearAlgebra
using StaticArrays
using Plots
using DelimitedFiles

using DifferentialEquations

using KEEP.PointMass2
using KEEP.PointMass2: compute_αhat, compute_OK, compute_Rτ, val_deriv_scnd_deriv, scnd_deriv_sample, τ_to_θφ

## Une simulation

τ0 = -asin(0.01/(50π/180))
dα0 = 0.
dτ0 = 2.

τ0 = 1e-10
dα0 = 0.
dτ0 = 0.

p = build_para()
u0 = init_u(τ0, dα0, dτ0)
tf = 20
tol = 1e-7

dynamics!(similar(u0), u0, p, 0)
ode_prob = ODEProblem(dynamics!, u0, [0, tf], p)

@time sol = solve(ode_prob, abstol=tol, reltol=tol);

function coeff_aero(u, p)
    begin
        α, _ = q = u[1:2]
        dα, _ = dq = u[3:4]

        # Compute values and derivatives
        Rτ, D_Rτ, DD_Rτ = val_deriv_scnd_deriv(q_ -> compute_Rτ(q_, p), q, p.diffbackend)
        OK, D_OK, DD_OK = val_deriv_scnd_deriv(Rτ_ -> compute_OK(Rτ_, p), Rτ, p.diffbackend)

        # Compute unit vectors
        αhat = compute_αhat(α)
        OA = p.l * αhat
        rhat = normalize(OK - OA)

        # Compute gravity force
        linear_density_l = π * p.ρ_l * (p.d_l^2) / 4
        m_l = p.nb_l * linear_density_l * p.r/2
        Fgrav = SA[0, 0, -p.g * (p.m + m_l)]

        # Compute aerodynamical force
        wind = SA[p.v_ref * abs(OK[3] / p.h_ref)^p.n_wind, 0, 0]
        kite_speed = D_OK * D_Rτ * dq
        app_wind = wind - kite_speed  # apparent wind, We

        # Wind projected in the plane generated by (θ_hat, φ_hat)
        app_wind_perp_to_lines = app_wind - (rhat ⋅ app_wind) * rhat
        ew = normalize(app_wind_perp_to_lines)

        xw = -normalize(app_wind)
        yw = rhat × ew
        zw = xw × yw

        lift_k = 1//2 * p.S * p.ρ_air * norm(app_wind)^2 * p.C_L
        drag_k = lift_k * p.C_D / p.C_L
        drag_l = 1//6 * p.nb_l * p.ρ_air * p.d_l * p.C_D_l * p.r * norm(app_wind_perp_to_lines)^2
        Faero_on_kite = -drag_k * xw - lift_k * zw
        Faero_on_lines = drag_l .* ew
        Faero = Faero_on_kite + Faero_on_lines

        # torque with same sign as dα, the torque applied by the arm on the generator
        torque = p.torque_func(dα, p)
        l_tension = rhat ⋅ (SA[0, 0, 1] × OA)
        A_tension = -p.I_eq / l_tension * rhat * SA[1, 0]'
        b_tension = -torque / l_tension * rhat

        A = p.m * D_OK * D_Rτ - A_tension
        b = (
            p.m * scnd_deriv_sample(DD_OK, D_Rτ * dq) +
            p.m * D_OK * scnd_deriv_sample(DD_Rτ, dq) +
            -b_tension - Fgrav - Faero
        )
        ddq = (D_OK' * A) \ (-D_OK' * b)
        Fcone = A * ddq + b
    end

    Faero_k_eq = Faero_on_kite + Fcone
    Fx = Faero_k_eq ⋅ xw
    Fy = Faero_k_eq ⋅ yw
    Fz = Faero_k_eq ⋅ zw

    Cx = -Fx / (1//2 * p.S * p.ρ_air * norm(app_wind)^2)
    Cy = -Fy / (1//2 * p.S * p.ρ_air * norm(app_wind)^2)
    Cz = -Fz / (1//2 * p.S * p.ρ_air * norm(app_wind)^2)
    return [Fx, Fy, Fz, Cx, Cy, Cz]
end

period = 3.095  # trouvé à la main
t = range(tf - period, tf, step=.001)
res = coeff_aero.(sol.(t), (p,))
Fx, Fy, Fz, Cx, Cy, Cz = eachrow(reduce(hcat, res))
α, τ, dα, dτ, P = eachrow(reduce(hcat, sol.(t)))

θ, φ = eachrow(reduce(hcat, τ_to_θφ.(τ, Ref(p))))

## Visualisation du sens de parcours.
# En vert : le position, en orange : les positions futures.
plot(φ, θ, xlim=(p.φ0-1.1p.Δφ, p.φ0+1.1p.Δφ), ylim=(p.θ0-1.1p.Δθ, p.θ0+1.1p.Δθ), label="")
scatter!(φ[1:50], θ[1:50], markerstrokewidth=0, label="sens de parcours")
scatter!(φ[1:1], θ[1:1], label="start")

## Plot Cx, Cy et Cz en fonction du temps
plot(title="Coeffs aero équivalents")
plot!(t, Cx, label="Cx")
plot!(t, Cy, label="Cy")
plot!(t, Cz, label="Cz")

## Plot finesse en fonction du temps
plot(t, Cz./Cx, title="Finesse équivalente", label="")

## Plot Cz(t) vs Cx(t)
plot(Cz, Cx, line_z=t, lw=20*Cx./Cz, label="",
xlabel="Cz", ylabel="Cx",
linecolor=:viridis, colorbar=true, colorbar_title="t (s)",
title="Cz(t) vs Cx(t)\nCourbe épaisse —> Finesse faible")

## Malheureusement on ne peut pas ajouter les lignes de niveau de la finesse car l'échelle de couleur est partagée avec le temps (line_z)
# resolution = 100
# Cz_range = range(minimum(Cz), maximum(Cz), length=resolution)
# Cx_range = range(minimum(Cx), maximum(Cx), length=resolution)
# contour!(Cz_range, Cx_range, (Cz_range' ./ Cx_range), levels=0:.5:10,
    # color=:black, clabels=true, colorbar=false)

## Enregistrer les résultats
open("./coeff_aero.csv", "w") do io
    write(io, "t (s), θ, φ, Fx (N), Fy (N), Fz (N), Cx, Cy, Cz\n")
    writedlm(io, stack([t, θ, φ, Fx, Fy, Fz, Cx, Cy, Cz]), ", ")
end
