module PointMass10

import LinearAlgebra: norm, normalize, ⋅, ×
using StaticArrays
import NaNMath as nm
import OrdinaryDiffEqTsit5: Tsit5
import ForwardDiff
using DiffResults
using Logging: @warn
using DiffEqCallbacks: ManifoldProjection
using ADTypes: AutoForwardDiff
using NonlinearSolve: NewtonRaphson
using KEEP.PointMassPara
using KEEP.TorqueFunction
using KEEP.Integrate: _integrate
import KEEP: DEFAULT_TOLERANCE

export dynamics!, integrate, build_manifold_projection

"""
Compute the polar angle θ and azimuthal angle φ given τ. Follows ISO 80000-2.
"""
function τ_to_θφ(τ, p)
	SA[
		p.θ0 + p.Δθ * sin(2 * τ)
		p.φ0 + p.Δφ * sin(τ)
	]
end

"""
Compute the Cartesian coordinates using R and τ.
"""
function Rτ_to_xyz(R, τ, p)
	θ, φ = τ_to_θφ(τ, p)
	SA[
		R * sin(θ) * cos(φ)
		R * sin(θ) * sin(φ)
		R * cos(θ)
	]
end

"""
Compute the Cartesian coordinates using α, θ2 and φ2.
"""
function αθ2φ2_to_xyz(α, θ2, φ2, p)
	SA[
		p.l * cos(α) + p.r * sin(θ2) * cos(φ2 + α)
		p.l * sin(α) + p.r * sin(θ2) * sin(φ2 + α)
		p.r * cos(θ2)
	]
end

@doc raw"""
``(\hat r, \hat theta_2, \hat \phi_2)`` in terms of ``(\hat x_1, \hat y_1, \hat z_1)``
"""
function rot2(q)	
	# This can be computed from compute_pos2 using ForwardDiff
	_, _, α, θ2, φ2 = q
	return SA[
		cos(α + φ2) * sin(θ2) cos(α + φ2) * cos(θ2) -sin(α + φ2)
		sin(α + φ2) * sin(θ2) sin(α + φ2) * cos(θ2) cos(α + φ2)
		cos(θ2)               -sin(θ2)              0
	]
end

"""
Compute the force of tension exerted by the lines on the kite.

Not used during the simulation, but available for later analysis.
"""
function Ftension_r(q, dq, ddq, p)
	_, _, _, θ2, φ2 = q
	_, _, dα, _, _ = dq
	_, _, ddα, _, _ = ddq
	return (p.I_eq * ddα - torque_function(dα, p)) / (p.l * sin(θ2) * sin(φ2))
end

"""
Compute the force of gravity on the solid kite + lines
"""
function Fgrav_func(q, p)
	linear_density_l = p.ρ_l * π * (p.d_l^2) / 4
	m_l = NB_LINES * linear_density_l * p.r/2
	return SA[0, 0, -p.g * (p.m + m_l)]
end

"""
Compute the aerodynamical force on the solid kite + lines
"""
function Faero_func(q, dq, p)
	# test OK with compute_pos2 & compute_speed2 to compute z (height of kite) and app_wind (apparent wind)
	z = compute_pos1(q, p)[3]
	wind = SA[p.v_ref * abs(z / p.h_ref)^(1 / p.n_wind), 0, 0]
	kite_speed = compute_speed1(q, dq, p)
	app_wind = wind - kite_speed  # We
	r_hat = rot2(q)[:, 1]  # er

	# Wind projected in the plane generated by (θ_hat, φ_hat)
	app_wind_perp_to_lines = app_wind - (r_hat ⋅ app_wind) * r_hat
	ew = normalize(app_wind_perp_to_lines)
	
	xw = -normalize(app_wind)
	yw = r_hat × ew
	zw = xw × yw

	lift_k = 1//2 * p.S * p.ρ_air * norm(app_wind)^2 * p.C_L
	drag_k = lift_k * p.C_D / p.C_L
	drag_l = 1//6 * NB_LINES * p.ρ_air * p.d_l * p.C_D_l * p.r * norm(app_wind_perp_to_lines)^2
	Faero_on_kite = -drag_k * xw - lift_k * zw
	Faero_on_lines = drag_l .* ew
	return Faero_on_kite + Faero_on_lines
end

"""
Compute the Jacobian-vector product between the Jacobian of the function `f` at position `x` and the vector `δx`.
"""
Jv(f, x, δx) = ForwardDiff.derivative(τ -> f(x .+ τ .* δx), 0.0)


# 1: use (R, τ)
# 2: use (α, θ2, φ2)

compute_pos1(q, p) = Rτ_to_xyz(q[1], q[2], p)
compute_speed1(q, dq, p) = Jv(q_ -> compute_pos1(q_, p), q, dq)
compute_accel1(q, dq, ddq, p) = Jv(dq_ -> compute_speed1(q, dq_, p), dq, ddq)

compute_pos2(q, p) = αθ2φ2_to_xyz(q[3], q[4], q[5], p)
compute_speed2(q, dq, p) = Jv(q_ -> compute_pos2(q_, p), q, dq)
compute_accel2(q, dq, ddq, p) = Jv(dq_ -> compute_speed2(q, dq_, p), dq, ddq)

compute_pos_diff(q, p) = compute_pos1(q, p) - compute_pos2(q, p)
compute_speed_diff(q, dq, p) = Jv(q_ -> compute_pos_diff(q_, p), q, dq)
compute_accel_diff(q, ddq, p) = Jv(dq_ -> compute_speed_diff(q, dq_, p), q, ddq)


function compute_posA(q, p)
    α = q[3]
    return SA[p.l * cos(α), p.l * sin(α), 0]
end
compute_speedA(q, dq, p) = Jv(q_ -> compute_posA(q_, p), q, dq)
compute_accelA(q, ddq, p) = Jv(dq_ -> compute_speedA(q, dq_, p), q, ddq)


@doc raw"""
Compute the residuals of the dynamics of the system given the state (`q` and `dq`) the forces (and torque) and the dynamics `ddq`.

# Examples

# Details of the calculation

Let ``x : q(t) ∈ \mathbb{R}^5 ↦ x(q(t)) ∈ \mathbb{R}^3`` and ``v = \dot x = ∂_q x(q) \dot q``, then
```maths
\begin{aligned*}
a = \dot v &= d_t(∂_q x) \dot q + ∂_q x \ddot q \\
&= ∂_q(d_t x) \dot q + ∂_q x \ddot q
\end{aligned*}
```.

To compute `Fapp`, consider ``mv`` instead of `v`;
to compute `resid1..3`, consider `OK1 - OK2` (the difference of positions) instead of `x`.
"""
function residuals(q, dq, ddq, p; Fgrav, Faero, torque)

    # 1. Pass a parametric function + its parameters (to optimize) instead of a function to recompile every time?
    # 2. To avoid recomputing forces: residuals(q, dq, ddq, p; Fgrav, Faero, torque)
    # 3. jacobians * vec -> Jv ?
    R, τ, α, θ2, φ2 = q
    _, _, ddα, _, _ = ddq

    ## Use automatic differentiation
    Fapp = p.m * (
        Jv(q_ -> compute_speed2(q_, dq, p), q, dq) +
        Jv(q_ -> compute_pos2(q_, p), q, ddq)
    )
    Ftension_kite = SA[(p.I_eq * ddα + torque) / (p.l * sin(θ2) * sin(φ2)), 0, 0]
    Fres = Fapp - Fgrav - Faero + rot2(q) * Ftension_kite

    ∂OK∂R = ForwardDiff.derivative(R_ -> compute_pos1(SA[R_, τ, α, θ2, φ2], p), R)
    ∂OK∂τ = ForwardDiff.derivative(τ_ -> compute_pos1(SA[R, τ_, α, θ2, φ2], p), τ)

    resid1 = Fres ⋅ ∂OK∂R
    resid2 = Fres ⋅ ∂OK∂τ / R
    resid3, resid4, resid5 = (
            Jv(q_ -> compute_speed_diff(q_, dq, p), q, dq) +
            Jv(q_ -> compute_pos_diff(q_, p), q, ddq)
    )
    return SA[resid1, resid2, resid3, resid4, resid5]
end


@doc raw"""
Compute du, the evolution of the state.

u = [R, τ, α, θ2, φ2, dR, dτ, dα, dθ2, dφ2]
du = [dR, dτ, dα, dθ2, dφ2, ddR, ddτ, ddα, ddθ2, ddφ2]

# Examples

# Details of the calculation

We have a function `residuals` linear in `ddq`, and we want to find its root.
We compute its Jacobian `M` wrt. `ddq` and its value `b` at `ddq = zeros(5)`.
Finally, we solve `ddq = - M \\ b` to get the dynamics.
"""
function dynamics!(du, u, p, t)
    q = u[1:5]
    dq = u[6:10]
    dα = dq[3]

    # Comptue forces
    Fgrav = Fgrav_func(q, p)
    Faero = Faero_func(q, dq, p)
    torque = torque_function(dα, p)

    # Compute ddq through M * ddq = b
    # M = ForwardDiff.jacobian(ddq_ -> residuals(q, dq, ddq_, p; Fgrav=Fgrav, Faero=Faero, torque=torque), zero(q))
    # b = -residuals(q, dq, zero(q), p; Fgrav=Fgrav, Faero=Faero, torque=torque)

    ddq_eval = zero(q)
    diffresult = DiffResults.DiffResult(zeros(eltype(q), 5), zeros(eltype(q), 5, 5))
    diffresult = ForwardDiff.jacobian!(diffresult, ddq_ -> residuals(q, dq, ddq_, p; Fgrav=Fgrav, Faero=Faero, torque=torque), ddq_eval)
    b = DiffResults.value(diffresult)
    M = DiffResults.jacobian(diffresult)

    instantaneous_power = torque * dα
    du[1:5] = dq
    du[6:10] = -M \ b
    du[11] = instantaneous_power
    du
end

### Initialisation

"""
Initialise the (augmented) state `u` in a geometrically possible configuration.
"""
function init_u(τ, dτ, p)
    q = init_q(τ, p)
    dq = init_dq(q, dτ, p)
    init_work = 0
    return [q..., dq..., init_work]
end

@doc raw"""
Initialise the state `q` in a geometrically possible configuration.

# Details of the calculation

We set ``α = 0`` to make the problem easier.

 1. To compute R, find the intersection between the line
```math
\{R (\sin(θ) \cos(φ), \sin(θ) \sin(φ), \cos(θ)), R \in \mathbb{R}^+\}
```
and the sphere of radius ``r`` centered in ``(l, 0, 0)``.
Substitute the coordinates of the point on the line into the following expression of the sphere
```math
\{(x, y, z) | (x-l)^2 + y^2 + z^2 = r^2\}
```
and solve the second order polynomial in ``R`` using the positive root, because we want the kite to be below the wind.

There will be a solution if ``r`` is big enough.
 2. find θ2 using ``R \cos(θ) = r \cos(θ2)``
 3. find φ2 using ``r \sin(θ2) \sin(φ2) = R \sin(θ) \sin(φ)``
"""
function init_q(τ, p)
    θ, φ = τ_to_θφ(τ, p)
    R = p.l * sin(θ) * cos(φ) + sqrt((p.l * sin(θ) * cos(φ))^2 + (p.r^2 - p.l^2))
    θ2 = acos(R * cos(θ) / p.r)
    φ2 = asin(R * sin(θ) * sin(φ) / (p.r * sin(θ2)))
    α = 0.
    return SA[R, τ, α, θ2, φ2]
end

"""
Initialise the speeds `dq` in a geometrically possible configuration given `q`.

# Details of the calculation

Differentiate the geometrical equations once wrt. time to get a linear system
of three equations. `dα=0` and `dτ` are given so the three equations are used to
determine `dR`, `dθ2`, and `dφ2`.

"""
function init_dq(q, dτ, p)
    R, τ, α, θ2, φ2 = q

    _, dphi2, dtheta2, dR, dtau = vitesse_init(α, φ2, θ2, R, τ, 0., dτ, p)

    dR, dτ, dα, dθ2, dφ2 = dR, dtau, 0., dtheta2, dphi2
    return SA[dR, dτ, dα, dθ2, dφ2]
end

include("generated/PointMass10_generated.jl")
"""
Compute how much (R, τ) and (α, θ2, φ2) and their derivatives disagree with each other.

The first three values are the difference in position between these two coordinates system, given in Cartesian coordinates, while the following three are the differences in speed. The rest is filled with zeros.
"""
function manifold_residuals!(res, u, p)
	@assert length(res) == 6 "res should have length 6"

	q = u[1:5]
	dq = u[6:10]

    res[1:3] .= compute_pos_diff(q, p)
    res[4:6] .= compute_speed_diff(q, dq, p)
	res
end

function integrate(y0, tf, p, alg=Tsit5(); save_everystep=false, tol=DEFAULT_TOLERANCE, kwargs...)
    return _integrate(dynamics!, y0, tf, p, alg; save_everystep=save_everystep, tol=tol, kwargs...)
end

"""
Make a callback that projects the manifold onto the tangent space of the manifold.

`y_prototype` is used to determine the type of `resid_prototype`.
"""
function build_manifold_projection(y_prototype; nlsolve=NewtonRaphson(), tol=DEFAULT_TOLERANCE, kwargs...)
	return ManifoldProjection(manifold_residuals!; autodiff = AutoForwardDiff(), resid_prototype = similar(y_prototype, 6), nlsolve=nlsolve, abstol=tol, reltol=tol, kwargs...)
end




end  # module