module PointMass4

import LinearAlgebra: norm, normalize, ⋅, ×
using StaticArrays
import NaNMath as nm
import OrdinaryDiffEqTsit5: Tsit5
import ForwardDiff

import KEEP.PointMass4 as PM4
using KEEP.PointMassPara
using KEEP.TorqueFunction
using KEEP.Integrate: _integrate
import KEEP: DEFAULT_TOLERANCE, TAU0

export dynamics, integrate

@doc raw"""
Compute the jacobian of `f` at `x`.
"""
function jacobian(f, x)
	## Integration using ForwardDiff is 25% faster compared to AbstractDifferentiation with ForwardDiff backend
	# return AD.jacobian(ab, f, x)[1]
	return ForwardDiff.jacobian(f, x)
end

@doc raw"""
Compute ``D²f(v, v)`` where
 - `f` is a vector valued function,
 - `v1` is the first sampling vector,
 - `v2` is the second sampling vector.

The output is a vector of length `length(f(x))`.
"""
function scnd_deriv_sample(f, x, v1, v2)
	## Integration using ForwardDiff is 25% faster compared to AbstractDifferentiation with ForwardDiff backend
	## jacobian-vector product should be done this way
	# return AD.jacobian(ab, τ2 -> AD.jacobian(ab, τ1 -> f(x + τ1 * v1 + τ2 * v2), 0.0)[1], 0.0)[1]
	return ForwardDiff.derivative(τ2 -> ForwardDiff.derivative(τ1 -> f(x + τ1 * v1 + τ2 * v2), 0.0), 0.0)
end

"""
Compute the polar angle θ and azimuthal angle φ given τ. Follows ISO 80000-2.
"""
function τ_to_θφ(τ, p)
	return p.θ0 + p.Δθ * sin(2τ), p.φ0 + p.Δφ * sin(τ)
end

@doc raw"""
Compute the coordinates of ``\hat α``.
"""
function compute_αhat(α)
	sin_α, cos_α = sincos(α)
	return SA[cos_α, sin_α, zero(α)]
end

@doc raw"""
Compute the coordinates of ``\hat τ``.
"""
function compute_τhat(τ, p)
	θ, φ = τ_to_θφ(τ, p)
	sin_θ, cos_θ = sincos(θ)
	sin_φ, cos_φ = sincos(φ)
	return SA[
		sin_θ * cos_φ,
		sin_θ * sin_φ,
		cos_θ
	]
end


@doc raw"""
(α, τ) -> (R, τ)
"""
function compute_Rτ(q, p)
	L, _, _ = lmt(p)
	α, τ = q
	dot_prod = compute_αhat(α) ⋅ compute_τhat(τ, p)
	# ε = 1e-5
	# my_sqrt(x) = sqrt(sqrt(x^2 + ε^2))
	return SA[
		L * (dot_prod + nm.sqrt(p.r^2 - (1 - dot_prod^2))), q[2]
	]
end

@doc raw"""
Compute the Cartesian coordinates using R and τ.
"""
function compute_OK(Rτ, p)
	R, τ = Rτ
	return R * compute_τhat(τ, p)
end


@doc raw"""
Compute du, the evolution of the state.

u = (α, τ, dα, dτ)
du = (dα, dτ, ddα, ddτ)
"""
function dynamics(u, p, t)
	L, M, T = lmt(p)
	α, _ = q = u[SA[1, 2]]
	dα, _ = dq = u[SA[3, 4]]

	# Compute values and derivatives
	Rτ = compute_Rτ(q, p)
	OK = compute_OK(Rτ, p)

	D_Rτ = jacobian(q -> compute_Rτ(q, p), q)
	dRτ = D_Rτ * dq
	D_OK = jacobian(Rτ -> compute_OK(Rτ, p), Rτ)

	ddRτ = scnd_deriv_sample(q_ -> compute_Rτ(q_, p), q, dq, dq)
	ddOK = scnd_deriv_sample(Rτ_ -> compute_OK(Rτ_, p), Rτ, dRτ, dRτ)

	# Compute unit vectors
	αhat = compute_αhat(α)
	OA = αhat * L
	rhat = normalize(OK - OA)

	# Compute gravity force
	Fgrav = SA[0, 0, -p.g - p.m_l * p.r] * M * L * T^-2

	# Compute aerodynamical force
	wind = SA[abs(OK[3] / (p.h_ref * L))^(1 / p.n_wind), 0, 0] * L * T^-1
	kite_speed = D_OK * dRτ
	app_wind = wind - kite_speed  # apparent wind, We

	# Wind projected in the plane generated by (θ_hat, φ_hat)
	app_wind_perp_to_lines = app_wind - (rhat ⋅ app_wind) * rhat
	ew = normalize(app_wind_perp_to_lines)
	
	xw = -normalize(app_wind)
	yw = rhat × ew
	zw = xw × yw

	lift_k = norm(app_wind)^2 * (p.c_L * M * L^-1)
	drag_k = lift_k / p.f
	drag_l = (p.c_D_l * M * L^-2) * (p.r * L) * norm(app_wind_perp_to_lines)^2
	Faero_on_kite = -drag_k * xw - lift_k * zw
	Faero_on_lines = drag_l * ew
	Faero = Faero_on_kite + Faero_on_lines

	# torque with same sign as dα, the torque applied by the arm on the generator
	torque = torque_function(dα * T, p) * M * L^2 * T^-2
	l_tension = rhat ⋅ (SA[0, 0, 1] × OA)
	A_tension = -(p.I_eq * M * L^2) / l_tension * rhat * SA[1, 0]'
	b_tension = -torque / l_tension * rhat
	
	D_OK_D_Rτ = D_OK * D_Rτ
	A = D_OK_D_Rτ .* M .- A_tension
	b = (
		ddOK * M +
		D_OK * ddRτ * M +
		-b_tension - Fgrav - Faero
	)
	instantaneous_power = torque * dα
	ddq = (D_OK' * A) \ (-D_OK' * b)
	return SA[dq[1], dq[2], ddq[1], ddq[2], instantaneous_power]
end


"""
[For post-processing]

Given u, p and possibly du, compute the line tension
"""
function compute_line_tension(u, p; du=PM4.dynamics(u, p, 0))
    L, M, T = lmt(p)
    α = u[1]
    dα = u[3]
    ddα = du[3]
    αhat = PM4.compute_αhat(α)
    OA = p.l * αhat
    OK = PM4.compute_OK(PM4.compute_Rτ(u, p), p)
    rhat = normalize(OK - OA)
    torque = torque_function(dα * T, p) * M * L^2 * T^-2
    l_tension = rhat ⋅ (SA[0, 0, 1] × OA)
    A_tension = -p.I_eq * M * L^2 / l_tension * rhat * SA[1, 0]'
    b_tension = -torque / l_tension * rhat
    F_tension = A_tension[:, 1] * ddα + b_tension
    return -F_tension ⋅ rhat
end
function create_u(α, τ, dα, dτ, W)
	return SA[α, τ, dα, dτ, W]
end

function init_u(α, dα, dτ; τ=TAU0, W=0.0)
	return create_u(α, τ, dα, dτ, W)
end

function integrate(u0, tf, p, alg=Tsit5(); save_everystep=false, tol=DEFAULT_TOLERANCE, kwargs...)
    return _integrate(dynamics, u0, tf, p, alg; save_everystep=save_everystep, tol=tol, kwargs...)
end



end  # module