module PointMass6

import LinearAlgebra: norm, normalize, ⋅, ×
using StaticArrays

using KEEP.PointMassPara
using KEEP.TorqueFunction
import KEEP.PointMass4: jacobian, scnd_deriv_sample

function compute_OK(q, p)
    return nothing
end

function dynamics(x, u, p, t)
	# L, M, T = lmt(p)
	# α, _, _ = q = y[SA[1, 2, 3]]
	# dα, _, _ = dq = y[SA[4, 5, 6]]

	# # Compute values and derivatives
	# OK = compute_OK(q, p)

	# D_OK = jacobian(Rτ -> compute_OK(Rτ, p), Rτ)

	# ddOK = scnd_deriv_sample(Rτ_ -> compute_OK(Rτ_, p), Rτ, dRτ, dRτ)

	# # Compute unit vectors
	# αhat = compute_αhat(α)
	# OA = p.l * αhat
	# rhat = normalize(OK - OA)

	# # Compute gravity force
	# Fgrav = SA[0, 0, -p.g - p.m_l * p.r] * M * L * T^-2

	# # Compute aerodynamical force
	# wind = SA[abs(OK[3] / (p.h_ref * L))^p.n_wind, 0, 0] * L * T^-1
	# kite_speed = dOK
	# app_wind = wind - kite_speed  # apparent wind, We

	# # Wind projected in the plane generated by (θ_hat, φ_hat)
	# app_wind_perp_to_lines = app_wind - (rhat ⋅ app_wind) * rhat
	# ew = normalize(app_wind_perp_to_lines)
	
	# xw = -normalize(app_wind)
	# yw = rhat × ew
	# zw = xw × yw

	# lift_k = norm(app_wind)^2 * (p.c_L * M * L^-1)
	# drag_k = lift_k / p.f
	# drag_l = (p.c_D_l * M * L^-2) * (p.r * L) * norm(app_wind_perp_to_lines)^2
	# Faero_on_kite = -drag_k * xw - lift_k * zw
	# Faero_on_lines = drag_l .* ew
	# Faero = Faero_on_kite + Faero_on_lines

	# # torque with same sign as dα, the torque applied by the arm on the generator
	# torque = torque_function(dα * T, p) * M * L^2 * T^-2
	# l_tension = rhat ⋅ (SA[0, 0, 1] × OA)
	# A_tension = -(p.I_eq * M * L^2) / l_tension * rhat * SA[1, 0]'
	# b_tension = -torque / l_tension * rhat
	
	# D_OK_D_Rτ = D_OK * D_Rτ
	# A = D_OK_D_Rτ .* M .- A_tension
	# b = (
	# 	ddOK * M +
	# 	D_OK * ddRτ * M +
	# 	-b_tension - Fgrav - Faero
	# )
	# instantaneous_power = torque * dα
	# ddq = (D_OK' * A) \ (-D_OK' * b)
	# return SA[dq[1], dq[2], ddq[1], ddq[2], instantaneous_power]
end

end