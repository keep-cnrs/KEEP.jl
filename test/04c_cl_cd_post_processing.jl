using LinearAlgebra
using StaticArrays
using Plots
using DelimitedFiles

# using DifferentialEquations

import KEEP.PointMass4 as PM4
import KEEP.PointMassPara as PMP
using KEEP.PointMass4: compute_αhat, compute_OK, compute_Rτ, scnd_deriv_sample, τ_to_θφ
import KEEP.TorqueFunction: torque_function

## Une simulation

τ0 = -asin(0.01 / (50π / 180))
dα0 = 0.
dτ0 = 2.

τ0 = 1e-10
dα0 = 0.
dτ0 = 0.

p_para = PMP.build_para()
p_vb = PMP.build_vbpara(p_para)
u0 = PM4.init_u(τ0, dα0, dτ0)
tf = 20
tol = 1e-7

# dynamics!(similar(u0), u0, p, 0)
# PM4.integrate uses out-of-place dynamics by default, but this example uses in-place.
# We will switch to PM4.integrate which uses Generic solver internally, or keep it consistent if PM4 requires OOP.
# Given PM4 is usually OOP (SVector), we should check if u0 is SVector. u0 is built with `init_u` which likely returns SVector or Vector.
# Line 22: u0 = init_u(...) -> likely StaticArrays.
# Line 26: dynamics!(...) -> suggests `dynamics!` exists.
# However, PM4.integrate abstracts this. Let's try to usage PM4.integrate(u0, tf, p; ...)
sol = PM4.integrate(u0, tf, p_vb; abstol=tol, reltol=tol);

function coeff_aero(u, p)
    begin
        α, _ = q = u[1:2]
        dα, _ = dq = u[3:4]

        # Compute values and derivatives
        Rτ = compute_Rτ(q, p)
        OK = compute_OK(Rτ, p)

        D_Rτ = PM4.jacobian(q_ -> compute_Rτ(q_, p), q)
        D_OK = PM4.jacobian(Rτ_ -> compute_OK(Rτ_, p), Rτ)

        # Compute unit vectors
        αhat = compute_αhat(α)
        OA = p.l * αhat
        rhat = normalize(OK - OA)

        # Compute gravity force
        linear_density_l = π * p.ρ_l * (p.d_l^2) / 4
        m_l = PMP.NB_LINES * linear_density_l * p.r / 2
        Fgrav = SA[0, 0, -p.g*(p.m+m_l)]

        # Compute aerodynamical force
        wind = SA[p.v_ref*abs(OK[3] / p.h_ref)^p.n_wind, 0, 0]
        kite_speed = D_OK * D_Rτ * dq
        app_wind = wind - kite_speed  # apparent wind, We

        # Wind projected in the plane generated by (θ_hat, φ_hat)
        app_wind_perp_to_lines = app_wind - (rhat ⋅ app_wind) * rhat
        ew = normalize(app_wind_perp_to_lines)

        xw = -normalize(app_wind)
        yw = rhat × ew
        zw = xw × yw

        lift_k = 1 // 2 * p.S * p.ρ_air * norm(app_wind)^2 * p.C_L
        drag_k = lift_k * p.C_D / p.C_L
        drag_l = 1 // 6 * PMP.NB_LINES * p.ρ_air * p.d_l * p.C_D_l * p.r * norm(app_wind_perp_to_lines)^2
        Faero_on_kite = -drag_k * xw - lift_k * zw
        Faero_on_lines = drag_l .* ew
        Faero = Faero_on_kite + Faero_on_lines

        # torque with same sign as dα, the torque applied by the arm on the generator
        torque = torque_function(dα, p)
        l_tension = rhat ⋅ (SA[0, 0, 1] × OA)
        A_tension = -p.I_eq / l_tension * rhat * SA[1, 0]'
        b_tension = -torque / l_tension * rhat

        A = p.m * D_OK * D_Rτ - A_tension
        # Second derivatives
        acc_Rτ = scnd_deriv_sample(q_ -> compute_Rτ(q_, p), q, dq, dq)
        dL_Rτ = D_Rτ * dq
        acc_OK = scnd_deriv_sample(Rτ_ -> compute_OK(Rτ_, p), Rτ, dL_Rτ, dL_Rτ)

        b = (
            p.m * acc_OK +
            p.m * D_OK * acc_Rτ +
            -b_tension - Fgrav - Faero
        )
        ddq = (D_OK' * A) \ (-D_OK' * b)
        Fcone = A * ddq + b
    end

    Faero_k_eq = Faero_on_kite + Fcone
    Fx = Faero_k_eq ⋅ xw
    Fy = Faero_k_eq ⋅ yw
    Fz = Faero_k_eq ⋅ zw

    Cx = -Fx / (1 // 2 * p.S * p.ρ_air * norm(app_wind)^2)
    Cy = -Fy / (1 // 2 * p.S * p.ρ_air * norm(app_wind)^2)
    Cz = -Fz / (1 // 2 * p.S * p.ρ_air * norm(app_wind)^2)
    return [Fx, Fy, Fz, Cx, Cy, Cz]
end

period = 3.095  # trouvé à la main
t = range(tf - period, tf, step=0.001)
res = coeff_aero.(sol.(t), (p_para,))
Fx, Fy, Fz, Cx, Cy, Cz = eachrow(reduce(hcat, res))
α, τ, dα, dτ, P = eachrow(reduce(hcat, sol.(t)))

res_θφ = τ_to_θφ.(τ, Ref(p_para))
θ = getindex.(res_θφ, 1)
φ = getindex.(res_θφ, 2)

## Visualisation du sens de parcours.
# En vert : le position, en orange : les positions futures.
plot(φ, θ, xlim=(p_para.φ0 - 1.1p_para.Δφ, p_para.φ0 + 1.1p_para.Δφ), ylim=(p_para.θ0 - 1.1p_para.Δθ, p_para.θ0 + 1.1p_para.Δθ), label="")
scatter!(φ[1:50], θ[1:50], markerstrokewidth=0, label="sens de parcours")
scatter!(φ[1:1], θ[1:1], label="start")

## Plot Cx, Cy et Cz en fonction du temps
plot(title="Coeffs aero équivalents")
plot!(t, Cx, label="Cx")
plot!(t, Cy, label="Cy")
plot!(t, Cz, label="Cz")

## Plot finesse en fonction du temps
plot(t, Cz ./ Cx, title="Finesse équivalente", label="")

## Plot Cz(t) vs Cx(t)
plot(Cz, Cx, line_z=t, lw=20 * Cx ./ Cz, label="",
    xlabel="Cz", ylabel="Cx",
    linecolor=:viridis, colorbar=true, colorbar_title="t (s)",
    title="Cz(t) vs Cx(t)\nCourbe épaisse —> Finesse faible")

## Malheureusement on ne peut pas ajouter les lignes de niveau de la finesse car l'échelle de couleur est partagée avec le temps (line_z)
# resolution = 100
# Cz_range = range(minimum(Cz), maximum(Cz), length=resolution)
# Cx_range = range(minimum(Cx), maximum(Cx), length=resolution)
# contour!(Cz_range, Cx_range, (Cz_range' ./ Cx_range), levels=0:.5:10,
# color=:black, clabels=true, colorbar=false)

# ## Enregistrer les résultats
if false
    open("./coeff_aero.csv", "w") do io
        write(io, "t (s), θ, φ, Fx (N), Fy (N), Fz (N), Cx, Cy, Cz\n")
        writedlm(io, stack([t, θ, φ, Fx, Fy, Fz, Cx, Cy, Cz]), ", ")
    end
end
